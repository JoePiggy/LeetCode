# 160题：相交链表(E)
## 题目分析
* 这道题的相交是指在地址空间上的相交，数值相等不一定相交，但是相交一定数值相等。
* 题目规定的相交是从交点开始往后全部相交，即尾部一定是对齐的。
* 关于这道题的输入第1，3，4个参数是为了辅助OJ来构造题意得链表
## 题解
* 令两链表尾部对齐以短的链表为基准向后遍历。
* 利用两个链表的长度差来实现，关键就是找到较长的链表的起始位置。
```C++
//柳神代码
class Solution
{
public:
    int getLengh(ListNode * head)
    {
        int len = 0;
        while(head != NULL)
        {
            head = head ->next;
            len ++;
        }
        return len;
    }
    ListNode* getStart(ListNode * head, int movelen)
    {
        while(movelen --)    head = head ->next;
        return head;
    }
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
    {
        if(headA == NULL || headB ==NULL)   return NULL;
        int lenA = getLengh(headA);
        int lenB = getLengh(headB);
        ListNode* p = headA;
        ListNode* q = headB;
        if(lenA > lenB)  p = getStart(headA, lenA - lenB);
        if(lenA < lenB)  q = getStart(headB, lenB - lenA);
        while(p != q && p && q)
        {
            p = p -> next;
            q = q -> next;

        }
        return p;
        
    }
};
```
## 拓展
来源：```https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md```
* 若不相交则a+b=b+a.若相交则a+b+c=b+a+c
* 缺点：超时，若不相交相当于每个链表都遍历的两边
```C++
class Solution
{
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
    {
        ListNode* p = headA;
        ListNode* q = headB;
        int i = 0;
        while(p != q)
        {
            p = (p -> next) ? p -> next : headB;
            q = (q -> next) ? q -> next : headA;    
        } 
        return p;
    }
};
```
## 总结
* 求链表长度
```C++
int getLengh(ListNode * head)
{
    int len = 0;
    while(head != NULL)
    {
        head = head ->next;
        len ++;
    }     
    return len;
}
```
* 找到较长的链表的起始位置
```C++
ListNode* getStart(ListNode * head, int movelen)
{
    while(movelen --)    head = head ->next;          //--novelen就少循环一次
    return head;
}
```
* 掌握```? :```的写法
```C++
p = (p -> next) ? p -> next : headB;
```
# 206题：链表反转(E)
## 题目分析
* 本题是不带头节点的链表反转问题
## 解题方法
### 柳神：
从前往后依次接在每一个结点的后面
* 每次前面的一串用```pre```来指向
* 进行接入的点用```cur```来指向
* 由于会修改```cur -> next```会影响找到下一个结点，因此在修改```cur -> next```之前要将```cur```的下一个结点保存为```temp```
```C++
class Solution{
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* temp = NULL;
        ListNode* pre = NULL;
        if(!cur)   return NULL;
        while(cur)
        {
            temp = cur -> next;
            cur -> next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```
### 头插法
https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#2-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC
```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head)   return NULL;
        ListNode* newHead = new ListNode(-1);
        ListNode* next = NULL;
        while(head)
        {
            next = head -> next;
            head -> next = newHead -> next;
            newHead -> next = head;
            head = next;   
        }
        return newHead -> next; 

    }
};
```
### 递归
注意递归中每次传入的参数都是本次的参数，返回后各个参数的值就是上一层递归中的值
```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !(head -> next))    return head;
        ListNode* next = head -> next;
        ListNode* newHead = reverseList(next);
        next -> next = head;
        head -> next = NULL;
        return newHead;
    }
};
```
## 总结
* 头结点和不带头结点的头插，没有头结点也要虚拟出一个，一个一个插入头结点和null之间
* 注意递归的每层的参数
# 21题：归并两个有序链表
## 解题方法
### 柳神：
```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* p = l1;
        ListNode* q = l2;
        ListNode* h = NULL;
        ListNode *t = NULL;
        if(p && q)
        {
             if(p -> val < p -> val)
            {
                h = p;
                t = p;
                p = p -> next;

             }
            else
            {
                h = q;
                t = q;
                q = q -> next;

            }
            while(p && q)
            {
                if(p -> val < q -> val)
                {
                    t -> next = p;
                    t = t -> next;
                    p = p -> next;

                }
                else
                {
                    t -> next = q;
                    t = t -> next;
                    q = q -> next;
                }    
            }    
           while(!p && q)  
           {
               t -> next = q;
               t = t -> next;
               q = q -> next;
           }   
           while(p && !q)  
           {
                t -> next = p;
                t = t -> next;
                p = p -> next;
           }
          while(!p && !q)    return h;
        }
        if(!p && q)     return q;
        if(p && !q)     return p;
        if(!p && !q)    return NULL;
    }
};
```
### 学习的递归：
```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        //学习的递归算法
        if(!l1)  return l2;
        if(!l2)  return l1;
        if(l1 -> val < l2 -> val)
        {
            l1 -> next = mergeTwoLists(l1 -> next, l2);
            return l1;
        }
        else
        {
            l2 -> next = mergeTwoLists(l1, l2 -> next);
            return l2;
        }     
        
    }
};
```
# 83题：从有序链表中删除重复结点(E)
## 题解
### 柳神解法
在内层的循环中不停的改变```p -> next```的指向
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head ||!(head -> next))  return head;
        ListNode * p = head;
        while(p && p -> next)
        {
            while(p -> next && p -> val == p -> next -> val)
            {
                p -> next = (p -> next) -> next;
            }
            p = p -> next;
        }
        return head;
    }
};
```
### 自己的解法
再声明一个指针q，用来在内层循环中来指向重复的值
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode * p = head;
        if(!p || !(p -> next))   return head;
        ListNode * q = p -> next;
        while(p && q)
        {
            while(q && p -> val == q -> val)
            {
                q = q -> next;
            }
            p -> next = q;
            p = p -> next;
            if(q)       //注意q在最后的NULL的时候，q -> next会是无效的
            {
                q = q -> next;
            }
            else
            {
                return head;
            }
            
        }
        return head;   
    }
};
```
### 学习的递归算法：
https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#4-%E4%BB%8E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !(head -> next))    return head;
        head -> next = deleteDuplicates(head -> next);
        return (head -> val == head -> next -> val) ? head -> next : head;
    }
};
```
# 19题：删除链表的倒数第n个结点(M)
## 题目分析
* 倒数第n个
* 第一个指针先正数n个，指向第n+1个
* 第二个指针从head开始往后
* 第一个的next是NULL时
* 第二个的next就是倒数第n个
* 可以看成一个快指针一个慢指针
### 参考柳神
```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* p = head;
        ListNode* q = head;
        if(!p || !(p -> next))  return NULL; 
        while (n --)
        {
            p = p -> next;
            if(!p)                        //注意:要是n正好时链表的长度，那就是链表的开头，不单独拿出来往后会产生空指针的问题
            {
                return head -> next;
            }
        }
        while(p -> next)
        {
            p = p -> next;
            q = q -> next;
        }
        q -> next =(q -> next) -> next;
        return head;
        
    }
};
```
# 24题：交换链表中的相邻结点（M）
## 题解
### 柳神做法
构造一个新的链表，空间复杂度是O(n)，h是新表头，t来遍历
```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* p  = head;
        if(!p || !(p -> next))  return head;
        ListNode* q = p -> next;
        ListNode *h = q;    //h是新的链表的头
        ListNode* t;    //t一直指向新链表的尾结点，t的下一个一定是q
        while(p && q)
        {
            p -> next = q -> next;
            q -> next = p;
            t = p;
            p = p -> next;
            if(p)
            {
                q = p -> next;
                if(q)
                {
                    t -> next = q;
                }else
                {
                    return h;
                }
            }else
            {
                return h;
            }
        }  
        return h;   
    }
};
```
### 学习的空间复杂度为O(1)的算法
https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#6-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E7%BB%93%E7%82%B9
为了与之后的循环保持一致，新构造一个节点用pre指向，每次的循环中都有pre -> next来连接交换位置的两个结点
```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* node  = new ListNode(-1);
        node -> next = head;
        ListNode* pre = node;
        ListNode* p = head;
        ListNode* q;
       // ListNode* q = head -> next;     //注意位置
        if(!p || !(p -> next))   return head;
        while(p && p -> next)
        {
            q = p -> next;
            p -> next = q -> next;
            q -> next = p;
            pre -> next = q;
            pre = p;
            p = pre -> next;
        }
        return node -> next;
    }
};
```

