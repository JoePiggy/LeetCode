# 160题：相交链表
## 题目分析
* 这道题的相交是指在地址空间上的相交，数值相等不一定相交，但是相交一定数值相等。
* 题目规定的相交是从交点开始往后全部相交，即尾部一定是对齐的。
* 关于这道题的输入第1，3，4个参数是为了辅助OJ来构造题意得链表
## 题解
* 令两链表尾部对齐以短的链表为基准向后遍历。
* 利用两个链表的长度差来实现，关键就是找到较长的链表的起始位置。
```C++
//柳神代码
class Solution
{
public:
    int getLengh(ListNode * head)
    {
        int len = 0;
        while(head != NULL)
        {
            head = head ->next;
            len ++;
        }
        return len;
    }
    ListNode* getStart(ListNode * head, int movelen)
    {
        while(movelen --)    head = head ->next;
        return head;
    }
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
    {
        if(headA == NULL || headB ==NULL)   return NULL;
        int lenA = getLengh(headA);
        int lenB = getLengh(headB);
        ListNode* p = headA;
        ListNode* q = headB;
        if(lenA > lenB)  p = getStart(headA, lenA - lenB);
        if(lenA < lenB)  q = getStart(headB, lenB - lenA);
        while(p != q && p && q)
        {
            p = p -> next;
            q = q -> next;

        }
        return p;
        
    }
};
```
## 拓展
来源：```https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md```
* 若不相交则a+b=b+a.若相交则a+b+c=b+a+c
* 缺点：超时，若不相交相当于每个链表都遍历的两边
```C++
class Solution
{
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
    {
        ListNode* p = headA;
        ListNode* q = headB;
        int i = 0;
        while(p != q)
        {
            p = (p -> next) ? p -> next : headB;
            q = (q -> next) ? q -> next : headA;    
        } 
        return p;
    }
};
```
## 总结
* 求链表长度
```C++
int getLengh(ListNode * head)
{
    int len = 0;
    while(head != NULL)
    {
        head = head ->next;
        len ++;
    }     
    return len;
}
```
* 找到较长的链表的起始位置
```C++
ListNode* getStart(ListNode * head, int movelen)
{
    while(movelen --)    head = head ->next;          //--novelen就少循环一次
    return head;
}
```
* 掌握```? :```的写法
```C++
p = (p -> next) ? p -> next : headB;
```
# 206题：链表反转
## 题目分析
* 本题是不带头节点的链表反转问题
## 解题方法
* 柳神：从前往后依次接在每一个结点的后面
* 每次前面的一串用```pre```来指向
* 进行接入的点用```cur```来指向
* 由于会修改```cur -> next```会影响找到下一个结点，因此在修改```cur -> next```之前要将```cur```的下一个结点保存为```temp```
```C++
class Solution{
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* temp = NULL;
        ListNode* pre = NULL;
        if(!cur)   return NULL;
        while(cur)
        {
            temp = cur -> next;
            cur -> next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```
* 头插法:```https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#2-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC```
```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head)   return NULL;
        ListNode* newHead = new ListNode(-1);
        ListNode* next = NULL;
        while(head)
        {
            next = head -> next;
            head -> next = newHead -> next;
            newHead -> next = head;
            head = next;   
        }
        return newHead -> next; 

    }
};
```
* 递归：注意递归中每次传入的参数都是本次的参数，返回后各个参数的值就是上一层递归中的值
```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !(head -> next))    return head;
        ListNode* next = head -> next;
        ListNode* newHead = reverseList(next);
        next -> next = head;
        head -> next = NULL;
        return newHead;
    }
};
```
## 总结
* 头结点和不带头结点的头插，没有头结点也要虚拟出一个，一个一个插入头结点和null之间
* 注意递归的每层的参数
