# 160题：相交链表
## 题目分析
* 这道题的相交是指在地址空间上的相交，数值相等不一定相交，但是相交一定数值相等。
* 题目规定的相交是从交点开始往后全部相交，即尾部一定是对齐的。
* 关于这道题的输入第1，3，4个参数是为了辅助OJ来构造题意得链表
## 题解
* 令两链表尾部对齐以短的链表为基准向后遍历。
* 利用两个链表的长度差来实现，关键就是找到较长的链表的起始位置。
```C++
//柳神代码
class Solution
{
public:
    int getLengh(ListNode * head)
    {
        int len = 0;
        while(head != NULL)
        {
            head = head ->next;
            len ++;
        }
        return len;
    }
    ListNode* getStart(ListNode * head, int movelen)
    {
        while(movelen --)    head = head ->next;
        return head;
    }
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
    {
        if(headA == NULL || headB ==NULL)   return NULL;
        int lenA = getLengh(headA);
        int lenB = getLengh(headB);
        ListNode* p = headA;
        ListNode* q = headB;
        if(lenA > lenB)  p = getStart(headA, lenA - lenB);
        if(lenA < lenB)  q = getStart(headB, lenB - lenA);
        while(p != q && p && q)
        {
            p = p -> next;
            q = q -> next;

        }
        return p;
        
    }
};
```
## 拓展
来源：```https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md```
* 若不相交则a+b=b+a.若相交则a+b+c=b+a+c
* 缺点：超时，若不相交相当于每个链表都遍历的两边
```C++
class Solution
{
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
    {
        ListNode* p = headA;
        ListNode* q = headB;
        int i = 0;
        while(p != q)
        {
            p = (p -> next) ? p -> next : headB;
            q = (q -> next) ? q -> next : headA;    
        } 
        return p;
    }
};
```
## 总结
* 求链表长度
```C++
int getLengh(ListNode * head)
{
    int len = 0;
    while(head != NULL)
    {
        head = head ->next;
        len ++;
    }     
    return len;
}
```
* 找到较长的链表的起始位置
```C++
ListNode* getStart(ListNode * head, int movelen)
{
    while(movelen --)    head = head ->next;          //--novelen就少循环一次
    return head;
}
```
* 掌握```? :```的写法
```C++
p = (p -> next) ? p -> next : headB;
```
